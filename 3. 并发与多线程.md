## III. 并发与多线程

### 1. 线程的生命周期与状态

#### 1.1 线程状态

##### 1. Java线程有哪几种基本状态？它们之间是如何转换的？ ★★★★☆

##### 2. 线程有几种状态，状态之间的流转是怎样的？（与上重复，合并） ★★★★☆

##### 3. 线程在哪些情况下会进入BLOCKED、WAITING和TIMED_WAITING状态？ ★★★★☆

#### 1.2 线程控制方法

##### 1. `wait()`、`sleep()`、`yield()`和`join()`方法有什么区别？ ★★★★☆

##### 2. `wait()`和`notify()/notifyAll()`方法为什么定义在`Object`类中？ ★★★★★

##### 3. `Thread.sleep(0)`的作用是什么？ ★★★☆☆

##### 4. 如何优雅地终止一个线程？为什么不推荐使用`Thread.stop()`？ ★★★★☆

##### 5. Java是如何判断一个线程是否存活的？ ★★★☆☆

### 2. 线程创建与管理

#### 2.1 线程创建方式

##### 1. Java中创建线程有哪几种方式？它们有什么区别和最佳实践？ ★★★★☆

##### 2. 创建线程有几种方式？（与上重复） ★★★★☆

##### 3. 直接调用线程的`run()`方法与调用`start()`方法有什么区别？ ★★★★☆

##### 4. `Runnable`和`Callable`接口有什么区别？`Future`在其中扮演什么角色？ ★★★★☆

#### 2.2 线程类型与调度

##### 1. 进程和线程的区别是什么？多线程的优势体现在哪些方面？ ★★★☆☆

##### 2. 什么是用户线程和守护线程？它们对JVM的生命周期有什么影响？ ★★★★☆

##### 3. 什么是线程调度？上下文切换（Context Switching）会带来什么开销？ ★★★★☆

##### 4. 什么是多线程中的上下文切换？ ★★★☆☆

#### 2.3 线程间数据共享与通信

##### 1. 父子线程之间怎么共享/传递数据？ ★★★★☆

### 3. 线程同步机制（synchronized, volatile, ReentrantLock）

#### 3.1 `synchronized` 关键字

##### 1. `synchronized`关键字的底层原理是什么？它能修饰哪些类型？ ★★★☆☆

##### 2. `synchronized`作用于实例方法和静态方法时，锁住的是什么？ ★★★★☆

##### 3. `synchronized`是如何保证原子性、可见性、有序性的？ ★★★★★

##### 4. `synchronized`的锁升级过程是怎样的？ ★★★★☆

##### 5. `synchronized`的重量级锁很慢，为什么还需要重量级锁？ ★★★☆☆

##### 6. `synchronized`的锁优化是怎样的？ ★★★☆☆

##### 7. `synchronized`是非公平锁吗，那么是如何体现的？ ★★★★☆

##### 8. `synchronized`的锁能降级吗？ ★★★☆☆

#### 3.2 `volatile` 关键字

##### 1. `volatile`关键字的作用是什么？它能保证原子性吗？为什么？ ★★★★☆

##### 2. `volatile`如何保证可见性和禁止指令重排序？底层实现原理是什么？ ★★★★★

##### 3. `int a = 1`是原子性操作吗？ ★★★☆☆

##### 4. 有了`synchronized`为什么还需要`volatile`？ ★★★★☆

##### 5. 有了MESI为啥还要JMM？ ★★★☆☆

#### 3.3 `synchronized` 与 `ReentrantLock` 对比

##### 1. `synchronized`和`ReentrantLock`有什么区别？各自的适用场景是什么？ ★★★★☆

##### 2. `ReentrantLock`相比`synchronized`有哪些高级特性？ ★★★★☆

#### 3.4 并发编程基本特性

##### 1. Java并发编程的三大特性（原子性、可见性、有序性）分别指什么？如何保证？ ★★★★☆

##### 2. 并发编程中的原子性和数据库ACID的原子性一样吗？ ★★★☆☆

##### 3. 有哪些实现线程安全的方案？ ★★★★☆

### 4. Java内存模型（JMM）与happens-before原则

#### 4.1 Java内存模型 (JMM)

##### 1. 什么是Java内存模型（JMM）？它解决了什么问题？ ★★★☆☆

##### 2. JMM中主内存和工作内存的概念是什么？线程对共享变量的操作是如何进行的？ ★★★★☆

##### 3. 什么是总线嗅探和总线风暴，和JMM有什么关系？ ★★★★☆

#### 4.2 happens-before原则

##### 1. 什么是happens-before原则？它在JMM中有什么作用？ ★★★★☆

##### 2. 列举并解释几种常见的happens-before规则。 ★★★★★

##### 3. `volatile`和`synchronized`如何根据happens-before原则保证可见性和有序性？ ★★★★★

##### 4. happens-before和as-if-serial有啥区别和联系？ ★★★★☆

### 5. JUC并发包（java.util.concurrent）

#### 5.1 JUC 核心组件

##### 1. JUC并发包中包含哪些核心组件？相比传统并发机制有什么优势？ ★★★☆☆

#### 5.2 并发工具类

##### 1. `Semaphore`（信号量）的用途是什么？它是如何实现资源访问控制的？ ★★★★☆

##### 2. `CountDownLatch`和`CyclicBarrier`有什么区别？它们各自的典型应用场景是什么？ ★★★★☆

##### 3. `CountDownLatch`、`CyclicBarrier`、`Semaphore`区别？ ★★★★☆

#### 5.3 并发集合

##### 1. 什么是`BlockingQueue`（阻塞队列）？它有哪些常见实现？虚假唤醒问题是什么？ ★★★★☆

##### 2. `ConcurrentHashMap`的并发实现原理在JDK 1.7和JDK 1.8中有什么不同？ ★★★★★

##### 3. `CopyOnWriteArrayList`的“写时复制”机制是什么？它的优缺点和适用场景？ ★★★★☆

### 6. 线程池（ThreadPoolExecutor）核心原理

#### 6.1 线程池基础

##### 1. 为什么需要线程池？使用线程池有哪些优势？ ★★★☆☆

##### 2. 什么是线程池？如何实现的？ ★★★★☆

#### 6.2 `ThreadPoolExecutor` 参数与工作流程

##### 1. `ThreadPoolExecutor`的七个核心参数分别代表什么含义？它们如何影响线程池的行为？ ★★★★★

##### 2. `ThreadPoolExecutor`的工作流程是怎样的？任务是如何被提交和执行的？ ★★★★☆

##### 3. 线程数设定成多少更合适？ ★★★★☆

##### 4. 线程池如何实现线程复用？请解释其底层原理。 ★★★★☆

##### 5. 如何合理设置线程池的核心参数，特别是针对CPU密集型和I/O密集型任务？ ★★★★★

##### 6. 为什么不建议通过`Executors`构建线程池？ ★★★☆☆

#### 6.3 线程池状态与管理

##### 1. 线程池有哪些核心状态？`shutdown()`和`shutdownNow()`方法有什么区别？ ★★★★☆

##### 2. 线程池的四种拒绝策略分别是什么？如何自定义拒绝策略？ ★★★★☆

##### 3. 线程池是如何被调度的？ ★★★☆☆

##### 4. `execute()`和`submit()`方法有什么区别？在异常处理方面有何不同？ ★★★★☆

##### 5. `CompletableFuture`的底层是如何实现的？ ★★★★☆

##### 6. `ForkJoinPool`和`ThreadPoolExecutor`区别是什么？ ★★★☆☆

##### 7. 如何让Java的线程池顺序执行任务？ ★★★☆☆

### 7. 原子类（Atomic 包）与CAS操作

#### 7.1 原子类与CAS 基础

##### 1. 什么是原子类（Atomic Classes）？它们的作用是什么？ ★★★☆☆

##### 2. 什么是CAS（Compare-And-Swap）操作？请解释其原理和三个核心参数。 ★★★★☆

##### 3. 什么是CAS？存在什么问题？ ★★★★☆

##### 4. CAS是如何实现无锁（Lock-Free）并发的？它有哪些优缺点？ ★★★★☆

##### 5. CAS在操作系统层面是如何保证原子性的？ ★★★☆☆

##### 6. 有了CAS为啥还需要`volatile`？ ★★★☆☆

#### 7.2 CAS 常见问题

##### 1. 什么是ABA问题？如何解决ABA问题？ ★★★★★

##### 2. 乐观锁和悲观锁的区别是什么？CAS属于哪种类型？ ★★★☆☆

##### 3. CAS一定有自旋吗？ ★★★☆☆

##### 4. 什么是Unsafe？ ★★★☆☆

### 8. 锁机制（公平/非公平锁, 读写锁, AQS）

#### 8.1 AQS 详解

##### 1. 什么是AQS（AbstractQueuedSynchronizer）？它的核心组件（`state`变量、CLH队列）是什么？ ★★★★★

##### 2. AQS是如何实现独占模式和共享模式的？ ★★★★★

##### 3. AQS是如何实现线程的等待和唤醒的？ ★★★★☆

##### 4. AQS的同步队列和条件队列原理？ ★★★★★

##### 5. AQS为什么采用双向链表？ ★★★★☆

#### 8.2 锁的分类与特性

##### 1. 公平锁和非公平锁有什么区别？`ReentrantLock`默认是哪种？为什么会有这种设计？ ★★★★☆

##### 2. 什么是读写锁（`ReentrantReadWriteLock`）？它解决了什么问题？ ★★★★☆

##### 3. `ReentrantReadWriteLock`的读锁和写锁是如何实现互斥和共享的？ ★★★★★

##### 4. 读写锁的`state`变量是如何同时表示读锁和写锁状态的？ ★★★★★

##### 5. 什么是可重入锁，怎么实现可重入锁？ ★★★★☆

##### 6. 如何实现无锁化编程？ ★★★☆☆

### 9. `ThreadLocal`

##### 1. `ThreadLocal`的作用和工作原理是什么？它与同步机制有什么根本区别？ ★★★★☆

##### 2. 什么是`ThreadLocal`，如何实现的？ ★★★★☆

##### 3. `ThreadLocal`有哪些常见的应用场景？举例说明。 ★★★☆☆

##### 4. `ThreadLocal`为什么会引起内存泄漏问题？如何避免？ ★★★★★

##### 5. `ThreadLocalMap`中的键和值分别是什么引用类型？为什么这样设计会导致内存泄漏？ ★★★★★

##### 6. 为什么InheritableThreadLocal为啥还需要TransmittableThreadLocal？ ★★★★☆

##### 7. 线程池中使用ThreadLocal会有哪些潜在的风险？ ★★★★☆

### 10. 其他并发问题

##### 1. 什么是竞态条件（Race Condition）？如何避免？ ★★★☆☆

##### 2. 什么是死锁（Deadlock）？发生死锁的四个必要条件是什么？如何避免死锁？ ★★★★★

##### 3. 什么是活锁（Livelock）和线程饥饿（Thread Starvation）？如何避免？ ★★★★☆

##### 4. 如何保证多线程下i++结果正确？ ★★★★☆

##### 5. 线程池中LongAdder和AtomicLong的区别？ ★★★☆☆

##### 6. 有三个线程T1,T2,T3如何保证顺序执行？ ★★★★☆

##### 7. 三个线程分别顺序打印0-100？ ★★★★☆

##### 8. 为什么不能在`try-catch`中捕获子线程的异常？ ★★★☆☆

##### 9. Java线程出现异常，进程为啥不会退出？ ★★★☆☆

##### 10. 什么是虚拟线程，JDK 21中的虚拟线程是怎么回事？ ★★★★☆

##### 11. 为什么虚拟线程不能用`synchronized`？ ★★★☆☆

##### 12. 为什么虚拟线程不要和线程池一起用？ ★★★☆☆

##### 13. 为什么虚拟线程尽量避免使用`ThreadLocal`？ ★★★☆☆

##### 14. 如何在Java中实现高效的异步编程？如何避免回调地狱？ ★★★★☆